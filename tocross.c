#pragma config(Sensor, S2,     color,          sensorEV3_Color)
#pragma config(Sensor, S3,     color,          sensorEV3_Color)
#pragma config(Motor,  motorB,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



// kp == 0.2 , kd == 0.5 (middle motors)



void pdreg (int ss1, int ss2, int speed, float kp, float kd){  //PDregulator inputs:(S1,S2, speed, kp, kd)
	int delta = ss1 - ss2;
	int pc = kp * delta;
	int deltaold;
	int dc = (delta - deltaold) * kd;
	int U = pc + dc;
	setMotorSpeed(motorB, speed + U);
	setMotorSpeed(motorC, (speed - U)*(-1));
	delta = deltaold;
	}



void enclinemove(int ecms, int egrad){ // var: ecms == encoder speed, egrad == encoder degrees
resetMotorEncoder(motorB);
while(getMotorEncoder(motorB) < egrad)
{
	pdreg(getColorReflected(S2), getColorReflected(S3), ecms, 0.2, 0.4);
}
}


void tocross(int speedC, int grad){     // enclineMove inputs:(speed of exit from cross, degrees of exit from cross)

		while(getColorReflected(S2) + getColorReflected(S3)>40){  // new inputs: speedC = ecms, egrad = grad
			pdreg(getColorReflected(S2), getColorReflected(S3), speedC, 0.2, 0.4);
}

enclinemove(speedC, grad); // <-- refresh of inputs

}


task main(){

tocross(20, 100);




}
