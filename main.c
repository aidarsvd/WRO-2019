#pragma config(Sensor, S2,     color,          sensorEV3_Color)
#pragma config(Sensor, S3,     color,          sensorEV3_Color)
#pragma config(Sensor, S4,     colordetect,    sensorEV3_Color)
#pragma config(Motor,  motorB,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Cvet = detect id color   //emove = encoder move

//pdreg = PDregulator      //tocross = cross

// kp == 0.2 , kd == 0.5 (middle motors)

int Cvet;//Peremennaya INT
int CD(){//Finkciya vozvrawaet int  (CD = Color Detect)
	Cvet = 0;
int hue = getColorHue(S4);
if(hue > 0 & hue < 30){
  Cvet = 5;	//Red
}
if(hue> 300 & hue < 360){
	Cvet =5;//Red
}
if(hue > 10 & hue< 90){
	Cvet = 4;	//Yellow
}
if(hue > 180 & hue < 260){
	Cvet = 3; // Blue
}
if (hue > 90 & hue < 150){
	Cvet = 2; // Green
}
return Cvet;//tut on vernul int

}

void crosstone(){   // play tone in begining of cross
if (getColorReflected(S2) + getColorReflected(S3) < 100)
	{
	playTone(500, 600);
	wait10Msec(20);
}

}

void pdreg (int ss1, int ss2, int speed, float kp, float kd){  //PDregulator inputs:(S1,S2, speed, kp, kd)
	int delta = ss1 - ss2;
	int pc = kp * delta;
	int deltaold;
	int dc = (delta - deltaold) * kd;
	int U = pc + dc;
	setMotorSpeed(motorB, speed + U);
	setMotorSpeed(motorC, (speed - U)*(-1));
	delta = deltaold;
	}

void enclinemove(int ecms, int egrad){ // var: ecms == encoder speed, egrad == encoder degrees
resetMotorEncoder(motorB);
while(getMotorEncoder(motorB) < egrad)
{
	pdreg(getColorReflected(S2), getColorReflected(S3), ecms, 0.2, 0.4);
}
}


void tocross(int speedC, int grad){     // enclineMove inputs:(speed of exit from cross, degrees of exit from cross)

		while(getColorReflected(S2) + getColorReflected(S3)>40){  // new inputs: speedC = ecms, egrad = grad
			pdreg(getColorReflected(S2), getColorReflected(S3), speedC, 0.2, 0.4);
}
crosstone();
enclinemove(speedC, grad); // <-- refresh of inputs
playTone(1000, 10);
wait10Msec(10);
}


void emove(int speed, int degrees){
resetMotorEncoder(motorB);
resetMotorEncoder(motorC);
while(getMotorEncoder(motorB) < degrees)
{
int deltas = getMotorEncoder(motorB) - getMotorEncoder(motorC);
setMotorSpeed(motorB, speed + deltas);
setMotorSpeed(motorC, (speed * (-1)) - deltas);
}
}








task main(){
}











}
